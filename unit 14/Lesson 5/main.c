/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "STM32F103x8.h"
#include "stm32f103x8_gpio_driver.h"
#include "lcd.h"
#include "keypad.h"
#include "stm32f103x8_EXTI_driver.h"
#include "stm32f103x8_USART_driver.h"
#include "stm32f103x8_SPI_driver.h"
#include "stm32f103x8_I2C_driver.h"
#include "I2C_Slave_EEPROM.h"


 uint8_t TASKA_flag,TASKB_flag,IRQ_Flag = 0;


extern int _estack;

#define TaskA_Stack_Size 100
#define TaskB_Stack_Size 100

//main stack pointer
unsigned int _S_MSP=&_estack;
unsigned int _E_MSP;

//Process stack pointer
unsigned int _S_PSP_TA;
unsigned int _E_PSP_TA;

unsigned int _S_PSP_TB;
unsigned int _E_PSP_TB;


typedef enum
{
	 Privileged,
	 Unprivileged
}CPUAccessLevel;
void SWITCH_CPU_ACCESSLEVEL(CPUAccessLevel level)
{
	 switch(level)
	 {
	 case Privileged:
		 //reset bit 0 in Control register
		 __asm("mrs r3,CONTROL");
		 __asm("lsr r3,r3,#0x1");
		 __asm("lsl r3,r3,#0x1");
		 __asm("msr CONTROL,r3");
		 break;

	 case Unprivileged:
		 //set bit 0 in Control register
		 __asm("mrs r3,CONTROL");
		 __asm("orr r3,r3,#0x1");
		 __asm("msr CONTROL,r3");
		 break;
	 }
}


#define OS_SWITCH_SP_2_PSP  	__asm volatile("MRS R0,CONTROL\n\t MOV R1,#0X2\n\t ORR R0,R0,R1\n\t MSR CONTROL,R0")
#define OS_SWITCH_SP_2_MSP		__asm volatile("MRS R0,CONTROL\n\t MOV R1,#0X5\n\t AND R0,R0,R1\n\t MSR CONTROL,R0")
#define OS_SWITCH_UNPRIVILEGED  __asm volatile("MRS R0,CONTROL\n\t MOV R1,#0X1\n\t ORR R0,R0,R1\n\t MSR CONTROL,R0")
#define OS_SWITCH_PRIVILEGED  	__asm volatile("MRS R0,CONTROL\n\t MOV R1,#0X6\n\t AND R0,R0,R1\n\t MSR CONTROL,R0")
#define OS_SET_PSP(address) 	__asm volatile("mov r0,%0\n\t msr PSP,r0": : "r"(address))
#define OS_Generate_Exception 	__asm volatile("SVC #0X3")

void SVC_Handler()
{
	OS_SWITCH_PRIVILEGED;
}






void EXTI9_CALLBACK(void)
{

	//IRQ_Flag = 1;
	if(IRQ_Flag==0)
	{
		TASKA_flag=1;
		TASKB_flag=0;
		IRQ_Flag = 1;
	}
	else if(IRQ_Flag==1)
	{
		TASKA_flag=0;
		TASKB_flag=1;
		IRQ_Flag = 0;
	}

}

int TaskA(int a,int b, int c)
{
	return a+b+c;
}

int TaskB(int a,int b, int c,int d)
{
	return a+b+c;
}

void MainOs()
{
	//Main Stack
	_E_MSP=(_S_MSP-512);
	//Task A
	_S_PSP_TA=(_E_MSP-8);
	_E_PSP_TA=(_S_PSP_TA-TaskA_Stack_Size);
	//Task B
	_S_PSP_TB=(_E_PSP_TA-8);
	_E_PSP_TB=(_S_PSP_TB-TaskB_Stack_Size);

	while(1)
	{
		__asm("NOP");
		if(TASKA_flag==1)
		{
			//Set PSP register = _S_PSP_TASKA
			OS_SET_PSP(_S_PSP_TA);
			//Switch from MSP to PSP
			OS_SWITCH_SP_2_PSP;
			//Switch to unpriveldged
			OS_SWITCH_UNPRIVILEGED;
			//call the task
			TASKA_flag=TaskA(1,2,3);
			//Set to priveldged //let the core interrupt itself to enter in handler mode "SVC handler"
			OS_Generate_Exception;
			//return to MSP
			OS_SWITCH_SP_2_MSP;
		}
		else if(TASKB_flag==1)
		{
			//Set PSP register = _S_PSP_TASKB
			OS_SET_PSP(_S_PSP_TB);
			//Switch from MSP to PSP
			OS_SWITCH_SP_2_PSP;
			//Switch to unpriveldged
			OS_SWITCH_UNPRIVILEGED;
			//Call the task
			TASKB_flag=TaskB(1,2,3,4);
			//Set to priveldged //let the core interrupt itself to enter in handler mode "SVC handler"
			OS_Generate_Exception;
			//return to MSP
			OS_SWITCH_SP_2_MSP;
		}
	}
}

int main(void)
{
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();

	//Set EXTI Configuration
	EXTI_PinConfig_t EXTIConfig;
	EXTIConfig.EXTI_PIN = EXTI9PB9;
	EXTIConfig.Trigger_Case = EXTI_Trigger_RISING;
	EXTIConfig.P_IRQ_CallBack = EXTI9_CALLBACK;
	EXTIConfig.IRQ_EN = EXTI_IRQ_Enable;
	MCAL_EXTI_GPIO_Init(&EXTIConfig);


	MainOs();
	IRQ_Flag = 1;

	while (1)
	{
		if(IRQ_Flag)
		{
			IRQ_Flag = 0;
		}
		else { /* Misra */ }
	}


}
